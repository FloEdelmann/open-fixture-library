#!/usr/bin/node

/**
 * @fileoverview This script generates a set of test fixtures that cover all defined fixture features (while
 * keeping the set as small as possible) and updates tests/test-fixtures.json and tests/test-fixtures.md.
 */

const fs = require(`fs`);
const path = require(`path`);
const chalk = require(`chalk`);

const { fixtureFromRepository } = require(`../lib/model.js`);
const register = require(`../fixtures/register.json`);
const manufacturers = require(`../fixtures/manufacturers.json`);

const fixtureFeaturesDirectory = path.join(__dirname, `../lib/fixture-features`);
const jsonFile = path.join(__dirname, `../tests/test-fixtures.json`);
const markdownFile = path.join(__dirname, `../tests/test-fixtures.md`);


const fixtureFeatures = [];
const featuresUsed = {}; // feature id -> times used
for (const featureFile of fs.readdirSync(fixtureFeaturesDirectory)) {
  if (path.extname(featureFile) === `.js`) {
    // module exports array of fix features
    const fixtureFeatureFile = require(path.join(fixtureFeaturesDirectory, featureFile));

    for (let index = 0; index < fixtureFeatureFile.length; index++) {
      const fixtureFeature = fixtureFeatureFile[index];

      // default id
      if (!(`id` in fixtureFeature)) {
        fixtureFeature.id = path.basename(featureFile, `.js`);
        if (fixtureFeatureFile.length > 1) {
          fixtureFeature.id += `-${index}`;
        }
      }

      // check uniqueness of id
      if (fixtureFeature.id in featuresUsed) {
        console.error(chalk.red(`[Error]`), `Fixture feature id '${fixtureFeature.id}' is used multiple times.`);
        process.exit(1);
      }

      fixtureFeatures.push(fixtureFeature);
      featuresUsed[fixtureFeature.id] = 0;
    }
  }
}

// check which features each fixture supports
let fixtures = [];
for (const manufacturerFixture of Object.keys(register.filesystem)) {
  const [manufacturerKey, fixtureKey] = manufacturerFixture.split(`/`);

  // pre-process data
  const fixture = fixtureFromRepository(manufacturerKey, fixtureKey);
  const fixtureResult = {
    man: manufacturerKey,
    key: fixtureKey,
    name: fixture.name,
    features: [],
  };

  // check all features
  for (const fixtureFeature of fixtureFeatures) {
    if (fixtureFeature.hasFeature(fixture)) {
      fixtureResult.features.push(fixtureFeature.id);
      featuresUsed[fixtureFeature.id]++;
    }
  }

  fixtures.push(fixtureResult);
}

// first fixtures are more likely to be filtered out, so we start with the ones with the fewest features
fixtures.sort((a, b) => {
  if (a.features.length === b.features.length) {
    return `${a.man}/${a.key}`.localeCompare(`${b.man}/${b.key}`, `en`);
  }

  return a.features.length - b.features.length;
});

// filter out
fixtures = fixtures.filter(fixture => {
  for (const feature of fixture.features) {
    // this is the only remaining fixture with that feature -> keep it
    if (featuresUsed[feature] === 1) {
      return true;
    }
  }
  // has no new features -> filter out
  for (const feature of fixture.features) {
    featuresUsed[feature]--;
  }
  return false;
});

// original alphabetic ordering
fixtures.sort((a, b) => {
  return `${a.man}/${a.key}`.localeCompare(`${b.man}/${b.key}`, `en`);
});

console.log(chalk.yellow(`Generated list of test fixtures:`));
for (const fixture of fixtures) {
  console.log(` - ${fixture.man}/${fixture.key}`);
}

fs.writeFile(jsonFile, `${JSON.stringify(fixtures, null, 2)}\n`, `utf8`, error => {
  if (error) {
    console.error(chalk.red(`[Fail]`), `Could not write test-fixtures.json`, error);
  }
  else {
    console.log(chalk.green(`[Success]`), `Updated ${jsonFile}`);
  }
});

fs.writeFile(markdownFile, getMarkdownCode(), `utf8`, error => {
  if (error) {
    console.error(chalk.red(`[Fail]`), `Could not write test-fixtures.md`, error);
  }
  else {
    console.log(chalk.green(`[Success]`), `Updated ${markdownFile}`);
  }
});

/**
 * Generates a markdown table presenting the test fixtures and all fix features.
 * @returns {String} The markdown code to be used in a markdown file.
 */
function getMarkdownCode() {
  const mdLines = [
    `# Test fixtures`,
    ``,
    `See the [fixture feature documentation](../docs/fixture-features.md). This file is automatically`,
    `generated by [\`cli/make-test-fixtures.js\`](../cli/make-test-fixtures.js).`,
    ``,
  ];

  // fixture list
  fixtures.forEach((fixture, index) => {
    mdLines.push(`${index + 1}. [*${manufacturers[fixture.man].name}* ${fixture.name}](../fixtures/${fixture.man}/${fixture.key}.json)`);
  });
  mdLines.push(``);

  // table head
  const tableHead = [`*Fixture number*`].concat(fixtures.map((fixture, index) => index + 1)).join(` | `);

  mdLines.push(tableHead);
  mdLines.push(`|-`.repeat(fixtures.length + 1));

  // table body
  const footnotes = [];
  fixtureFeatures.forEach((fixtureFeature, index) => {
    let line = `**${fixtureFeature.name}**`;

    if (fixtureFeature.description) {
      footnotes.push(fixtureFeature.description);
      const n = footnotes.length;
      line += ` [<sup>[${n}]</sup>](#user-content-footnote-${n})`;
    }

    for (const fixture of fixtures) {
      line += fixture.features.includes(fixtureFeature.id) ? ` | ✅` : ` | ❌`;
    }

    mdLines.push(line);

    // repeat table head
    if ((index + 1) % 15 === 0) {
      mdLines.push(tableHead);
    }
  });
  mdLines.push(``);

  // footnotes
  mdLines.push(`## Footnotes`, ``);
  for (const [index, footnote] of footnotes.entries()) {
    mdLines.push(`**<a id="user-content-footnote-${index + 1}">[${index + 1}]</a>**: ${footnote}  `);
  }
  mdLines.push(``);

  return mdLines.join(`\n`);
}
